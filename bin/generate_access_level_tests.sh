#!/bin/bash

# Define the output file location
output_file="Tests/MemberwiseInitTests/MemberwiseInitAccessLevelTests.swift"

# Check for dirty changes in the target file
if git diff --name-only | grep -q "$output_file"; then
  echo "Error: $output_file has uncommitted changes. Commit or stash them before running this script."
  exit 1
fi

# Extract the class name from the output file name
class_name=$(basename "$output_file" .swift)

# Define the possible values for each variable
access_levels=("private" "" "public")

# Initialize init_modifiers with an empty string and access levels
init_modifiers=("")
for level in "${access_levels[@]}"; do
  if [ -n "$level" ]; then
    init_modifiers+=("@Init(.$level)")
  else
    # For the empty/default case, use "@Init(.internal)"
    init_modifiers+=("@Init(.internal)")
  fi
done

# NB: '[none]' represents case where a struct has no properties
property_access_levels=("private" "" "public" "[none]")

capitalize() {
  echo "$1" | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2));}1'
}

# Start writing to the output file
{
  echo "// This file is automatically generated by '../../bin/generate_access_level_tests.sh'."
  echo "// Do not edit this file directly."
  echo ""
  echo "import MacroTesting"
  echo "import MemberwiseInitMacros"
  echo "import SwiftSyntaxMacros"
  echo "import XCTest"
  echo ""
  echo "final class $class_name: XCTestCase {"
  echo "  override func invokeTest() {"
  echo "    // NB: Waiting for swift-macro-testing PR to support explicit indentationWidth: https://github.com/pointfreeco/swift-macro-testing/pull/8"
  echo "    withMacroTesting("
  echo "      //indentationWidth: .spaces(2),"
  echo "      //isRecording: true,"
  echo "      macros: ["
  echo "        \"MemberwiseInit\": MemberwiseInitMacro.self,"
  echo "        \"Init\": InitMacro.self,"
  echo "      ]"
  echo "    ) {"
  echo "      super.invokeTest()"
  echo "    }"
  echo "  }"
  echo ""

  # Generate test cases for each combination of values
  for memberwise_access in "${access_levels[@]}"; do
    for struct_access in "${access_levels[@]}"; do
      for property_access in "${property_access_levels[@]}"; do
        
        # If property is [none], we don't want to iterate over different init_modifiers
        if [ "$property_access" == "[none]" ]; then
          init_modifiers_temp=("")
        else
          init_modifiers_temp=("${init_modifiers[@]}")
        fi

        for init_modifier in "${init_modifiers_temp[@]}"; do
          
          memberwise_str=$([ -z "$memberwise_access" ] && echo "" || echo ".$memberwise_access")
          struct_str=$([ -z "$struct_access" ] && echo "" || echo "$struct_access")
          init_str=$([ -z "$init_modifier" ] && echo "" || echo "$init_modifier")
          property_str=$([ -z "$property_access" ] && echo "" || echo "$property_access")
          
          init_name=$(echo "$init_modifier" | sed -E 's/@Init\((.*)\)/\1/' | tr -d '.' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2));}1')
          
          # Adjusting the test name for the "[none]" property access case
          test_property_name=$([ "$property_access" == "[none]" ] && echo "No" || echo "$(capitalize ${property_access:-default})")

          test_name="testMemberwiseInit$(capitalize ${memberwise_access:-default})_$(capitalize ${struct_access:-default})Struct_${init_name:+Init}${init_name}_${test_property_name}Property"
          test_name="${test_name//,/_}"
          test_name="${test_name// /}"
          test_name="${test_name//__/_}"

          echo "  func $test_name() {"
          echo "    assertMacro(applyFixIts: false) {"
          echo "      \"\"\""
          echo "      @MemberwiseInit${memberwise_str:+($memberwise_str)}"
          echo "      ${struct_str}${struct_str:+ }struct S {"

          # Only add the property declaration if property_access is not '[none]'
          if [ "$property_access" != "[none]" ]; then
            echo "        ${init_str}${init_str:+ }${property_str}${property_str:+ }let v: T"
          fi

          echo "      }"
          echo "      \"\"\""
          echo "    }"
          echo "  }"
          echo ""
        done
      done
    done
  done

  echo "}"

} > "$output_file"

echo "Test file generated at $output_file"
